#!/usr/bin/perl
# Описание основных функций модуля Test::More

use Modern::Perl;
use Military_materiel;
use Test::More tests => 27; # подключаем модуль и указываем количество выполняемых тестов

ok( 1 == 1, 'Test name 1' ); # входное значение соответствует ожидаемому
                             # Test name 1 - это короткое описание теста (будет напечатано)

is( 1, 1, 'Test name 2' ); # входное значение соответсвует ожидаемому (лучший отчет в случае неудачи)

isnt( 1, 2, 'Test name 3' ); # входное значение не соответсвует ожидаемому

like( 123, '/\d+/', 'Test name 4' ); # входное значение соответсвует шаблону (регулярному выражению)

unlike( 'text', '/\d+/', 'Test name 5' ); # входное значение не соответсвует шаблону (регулярному выражению)

cmp_ok( 1, '<=', 2, 'Test name 6' ); # сравнение значений с помощью бинарных операторов сравнения Perl
                                     # это нечто среднее между ok() и is()

can_ok( 'Military_materiel', qw( new )); # может-ли модуль (класс) выполнить метод или список методов
#can_ok( $object, qw( some_method )); может-ли объект выполнить метод или список методов

# если проверяется несколько методов в вышеуказанном варианте будет засчитано выполнение одного теста
my @methods = qw( new moving flying );
foreach my $methods (@methods) { # в данном случае будет засчитано выполнение трех тестов
           can_ok('Military_materiel', $methods);
}

my $unit = Military_materiel->new( 'plane', 'SU-27', '200', '250', '300', 'rocket', '5' );
isa_ok( $unit, 'Military_materiel', 'Test customer' ); # был-ли создан объект и принадлежит-ли он к классу

isa_ok( 'Military_materiel', 'Weapon_type', 'Test customer' ); # имеет-ли класс правого предка

my @array = ( 1, 2, 3 );
my $array_ref = \@array;
isa_ok( $array_ref, 'ARRAY' ); # также возможно проверить и ссылку на массив

my @args = ( 'tank', 'T-34', '80', '350', '200', 'cannon', '50' );
my $unit1 = new_ok( 'Military_materiel' => \@args, 'Test customer' ); # объединение создания объекта класса и вызова isa_ok()

# subtest() запускает свой собственный код с набором подтестов (если все подтесты пройдены вернет true)
# можно передавать параметры как функции
pass( 'First test' );
subtest 'An example subtest' => sub {
                                     plan tests => 2;
                                     pass( 'This is a subtest' );
                                     pass( 'So is this' );
                                     done_testing(); # необязательно писать
                                    };
pass( 'Third test' );

pass( 'Test name' ); # напечатать сообщение, что тест успешно пройден
#fail( $test_name ); # напечатать сообщение, что тест провалился

use_ok( 'Weapon_type' ); # проверка возможности подключения модуля или списка модулей
                         # также автоматически подключает модуль как директива use

my @imports = qw( new moving flying );
use_ok( 'Weapon_type', @imports ); # тоже что и выше, но с указанием списка импортируемых функций из модуля
                                   # будет проведена проверка возможности подключения этих функций

require_ok( 'Weapon_type' ); # проверка возможности загрузки модуля или списка модулей
require_ok( 'Military_materiel.pm' ); # проверка возможности загрузки файла или списка файлов
                                      # тоже что и use_ok, только вместо use используется require

my $ref1 = { key => 'value' };
my $ref2 = { key => 'value' };
is_deeply( $ref1, $ref2, 'Test name 23' ); # эквивалентны-ли две сложные структуры данных
                                           # проверяется содержание ссылок на эти структуры

diag( 'My tests ok!' ); # позволяет напечатать диагностическое сообщение
ok( 1 == 1, 'Test name 24' ) or diag( 'Input value ne 1!' ); # также можно использовать массив сообщений

note('Some note'); # позволяет оставить полезные для отладки заметки, которые не указывают на проблему

# explain покажет содержимое ссылок в удобном для чтения формате
my $value3 = '1 2 3';
my $value4 = '1 2 3';
is_deeply( $value3, $value4, 'Test name 25' ) || diag explain $value3;

my $value5 = 2; # для условия, которое можно не указывать и в SKIP и в TODO
SKIP: { # специально пропустить тест, чтобы его провал не привел к смерти всего кода
     skip 'Not installed JSON::XS', 1 if $value5 == 2; # причина, количество тестов для пропуска

     #...программный код тестов...
} # помеченные тесты будут пропущены (рекомендуется реже использовать SKIP)

TODO: { # объявить блок тестов, которые могут завершится неудачей по некоторым причинам
    local $TODO = 'Not finished some function!' if $value5 == 2; # причина
 
    #...программный код тестов...
} # помеченные тесты выполнятся, но будут помечены как непройденные или пропущенные

TODO: { # пропустить неудавшиеся тесты по некоторой причине (аналогичен SKIP)
    todo_skip 'Not finished some function!', 1 if $value5 == 2;
 
    #...программный код тестов...
}
# SKIP используем когда причина не зависит от нас (например, используется другая ОС)
# TODO используем если просто еще что-то не реализовали

#BAIL_OUT('Some reason'); # используем когда тестирование не может продолжаться (есть какой-то сбой)

# Коды выхода модуля Test::More:
# 0 - все тесты успешно пройдены
# 255 - какой-либо тест умер или все не пройдены
# другой номер - сколько тестов не пройдены